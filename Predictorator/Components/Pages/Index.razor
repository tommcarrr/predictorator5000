@page "/"
@using System.Text
@rendermode InteractiveServer
@inject NavigationManager NavigationManager
@inject IFixtureService FixtureService
@inject IDateRangeCalculator DateRangeCalculator
@inject BrowserInteropService Browser
@using Predictorator.Components

<CeefaxDisplay />

<h1>Premier League Fixtures</h1>

<MudPaper Class="d-flex align-center justify-center gap-2 my-4" Elevation="1">
    <MudIconButton Icon="@Icons.Material.Filled.ChevronLeft" Disabled="!_autoWeek" OnClick="@(() => ChangeWeek(-1))"
                   UserAttributes="@(new Dictionary<string, object>{{"id","prevWeekBtn"}})" />
    <MudText Typo="Typo.h6" Class="d-flex align-center cursor-pointer" @onclick="TogglePicker">
        @($"{_fromDate:dd/MM/yyyy} - {_toDate:dd/MM/yyyy}")
        <MudIcon Icon="@(_showPicker ? Icons.Material.Filled.ExpandLess : Icons.Material.Filled.ExpandMore)" Class="ml-1" />
    </MudText>
    <MudIconButton Icon="@Icons.Material.Filled.ChevronRight" Disabled="!_autoWeek" OnClick="@(() => ChangeWeek(1))"
                   UserAttributes="@(new Dictionary<string, object>{{"id","nextWeekBtn"}})" />
    <MudIconButton Icon="@Icons.Material.Filled.Refresh" Disabled="_autoWeek" OnClick="ResetRange"
                   UserAttributes="@(new Dictionary<string, object>{{"id","resetBtn"}})" />
</MudPaper>
<MudCollapse Expanded="_showPicker">
    <MudDateRangePicker DateRange="_selectedRange" DateRangeChanged="RangeChanged" Class="my-2"
                       UserAttributes="@(new Dictionary<string, object>{{"id","dateRangePicker"}})" />
</MudCollapse>

@if (_fixtures == null)
{
    <p>Loading...</p>
}
else if (_fixtures.Response.Any())
{
    var groups = _fixtures.Response.GroupBy(f => f.Fixture.Date.Date).OrderBy(g => g.Key);
    foreach (var group in groups)
    {
        <MudPaper Class="my-4" Elevation="1">
            <MudText Typo="Typo.h6" Class="pa-2">@group.Key.ToString("dddd, MMMM d, yyyy")</MudText>
            <MudPaper Class="pa-2">
                @foreach (var fixture in group.OrderBy(x => x.Fixture.Date).ThenBy(x => x.Teams.Home.Name))
                {
                    <div class="fixture-row">
                        <div class="fixture-line">
                            <MudImage Src="@fixture.Teams.Home.Logo" Alt="@fixture.Teams.Home.Name" Width="30" Height="30" />
                            <span class="team-name home-name">@fixture.Teams.Home.Name</span>
                            <MudNumericField T="int?" Class="score-input" Immediate="true"
                                             @bind-Value="_predictions[fixture.Fixture.Id].Home"
                                             Disabled="@(fixture.Score?.Fulltime.Home != null)" Max="20" Min="0" />
                            <span class="hyphen">-</span>
                            <MudNumericField T="int?" Class="score-input" Immediate="true"
                                             @bind-Value="_predictions[fixture.Fixture.Id].Away"
                                             Disabled="@(fixture.Score?.Fulltime.Away != null)" Max="20" Min="0" />
                            <span class="team-name away-name">@fixture.Teams.Away.Name</span>
                            <MudImage Src="@fixture.Teams.Away.Logo" Alt="@fixture.Teams.Away.Name" Width="30" Height="30" />
                        </div>
                        <div class="fixture-info mud-text-secondary">
                            @{ var ukTz = TimeZoneInfo.FindSystemTimeZoneById("GMT Standard Time");
                               var uk = TimeZoneInfo.ConvertTime(fixture.Fixture.Date, ukTz); }
                            @uk.ToString("h:mm tt") - @fixture.Fixture.Venue.Name, @fixture.Fixture.Venue.City
                        </div>
                    </div>
                }
            </MudPaper>
        </MudPaper>
    }
}

<MudStack Class="mt-4" Row="true" Spacing="2">
    <MudButton Color="Color.Secondary" Variant="Variant.Filled" OnClick="@FillRandomScores"
               UserAttributes="@(new Dictionary<string, object>{{"id","fillRandomBtn"}})">Complete with Random Scores</MudButton>
    <MudButton Color="Color.Warning" Variant="Variant.Filled" OnClick="@ClearScores"
               UserAttributes="@(new Dictionary<string, object>{{"id","clearBtn"}})">Clear Predictions</MudButton>
    <MudButton Color="Color.Success" Variant="Variant.Filled" OnClick="@CopyPredictionsAsync"
               UserAttributes="@(new Dictionary<string, object>{{"id","copyBtn"}})">Copy Predictions to Clipboard</MudButton>
</MudStack>

@code {
    private FixturesResponse? _fixtures;
    private DateTime? _fromDate;
    private DateTime? _toDate;
    private bool _autoWeek;
    private bool _showPicker;
    private int _currentWeekOffset;
    private readonly Dictionary<int, PredictionInput> _predictions = new();
    private DateRange _selectedRange = new(null, null);

    [Parameter, SupplyParameterFromQuery(Name = "fromDate")] public DateTime? FromDate { get; set; }
    [Parameter, SupplyParameterFromQuery(Name = "toDate")] public DateTime? ToDate { get; set; }
    [Parameter, SupplyParameterFromQuery(Name = "weekOffset")] public int? WeekOffset { get; set; }

    protected override async Task OnParametersSetAsync()
    {
        var query = QueryHelpers.ParseQuery(new Uri(NavigationManager.Uri).Query);
        if (!query.ContainsKey("fromDate")) FromDate = null;
        if (!query.ContainsKey("toDate")) ToDate = null;
        if (!query.ContainsKey("weekOffset")) WeekOffset = null;

        var (from, to) = DateRangeCalculator.GetDates(FromDate, ToDate, WeekOffset);
        _fromDate = from;
        _toDate = to;
        _selectedRange = new DateRange(from, to);
        _currentWeekOffset = WeekOffset ?? 0;
        _autoWeek = FromDate == null && ToDate == null;
        _fixtures = await FixtureService.GetFixturesAsync(from, to);

        if (_fixtures?.Response != null)
        {
            foreach (var f in _fixtures.Response)
            {
                if (!_predictions.ContainsKey(f.Fixture.Id))
                    _predictions[f.Fixture.Id] = new PredictionInput();

                _predictions[f.Fixture.Id].Home = f.Score?.Fulltime.Home;
                _predictions[f.Fixture.Id].Away = f.Score?.Fulltime.Away;
            }
        }
    }

    private void Reload()
    {
        var uri = QueryHelpers.AddQueryString("/", new Dictionary<string, string?>
        {
            ["fromDate"] = _fromDate?.ToString("yyyy-MM-dd"),
            ["toDate"] = _toDate?.ToString("yyyy-MM-dd")
        });
        NavigationManager.NavigateTo(uri);
    }

    private void RangeChanged(DateRange range)
    {
        if (range.Start.HasValue && range.End.HasValue)
        {
            var newFrom = range.Start.Value.Date;
            var newTo = range.End.Value.Date;
            if (newFrom == _fromDate && newTo == _toDate)
                return;

            _selectedRange = range;
            _fromDate = newFrom;
            _toDate = newTo;
            Reload();
        }
    }

    private void TogglePicker()
    {
        _showPicker = !_showPicker;
    }

    private void ChangeWeek(int delta)
    {
        var offset = _currentWeekOffset + delta;
        var uri = QueryHelpers.AddQueryString("/", new Dictionary<string, string?>
        {
            ["weekOffset"] = offset.ToString()
        });
        NavigationManager.NavigateTo(uri);
    }

    private void FillRandomScores()
    {
        var possible = new[] { 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,2,2,2,2,2,2,2,2,2,2,2,2,2,2,3,3,3,3,3,3,3,4,4,5 };
        var rnd = new Random();
        if (_fixtures == null) return;

        foreach (var f in _fixtures.Response)
        {
            var pred = _predictions[f.Fixture.Id];
            if (f.Score?.Fulltime.Home == null && pred.Home == null)
                pred.Home = possible[rnd.Next(possible.Length)];
            if (f.Score?.Fulltime.Away == null && pred.Away == null)
                pred.Away = possible[rnd.Next(possible.Length)];
        }
    }

    private void ClearScores()
    {
        if (_fixtures == null) return;
        foreach (var f in _fixtures.Response)
        {
            var pred = _predictions[f.Fixture.Id];
            if (f.Score?.Fulltime.Home == null)
                pred.Home = null;
            if (f.Score?.Fulltime.Away == null)
                pred.Away = null;
        }
    }

    private async Task CopyPredictionsAsync()
    {
        if (_fixtures == null) return;

        var sbText = new StringBuilder();
        var sbHtml = new StringBuilder();
        bool missing = false;
        sbHtml.Append("<table border=\"1\" cellpadding=\"5\" cellspacing=\"0\" style=\"border-collapse: collapse;\">");

        var groups = _fixtures.Response.GroupBy(f => f.Fixture.Date.Date).OrderBy(g => g.Key);
        foreach (var group in groups)
        {
            var dateHeader = group.Key.ToString("dddd, MMMM d, yyyy");
            sbText.AppendLine(dateHeader);
            sbHtml.Append($"<thead><tr><th colspan=\"3\" style=\"background-color: #f2f2f2; text-align: center; padding: 10px;\">{dateHeader}</th></tr>");
            sbHtml.Append("<tr><th style=\"background-color: #d9d9d9; text-align: left; padding: 5px; min-width: 120px\">Home Team</th>");
            sbHtml.Append("<th style=\"background-color: #d9d9d9; text-align: center; padding: 5px;\">Score</th>");
            sbHtml.Append("<th style=\"background-color: #d9d9d9; text-align: right; padding: 5px; min-width: 120px\">Away Team</th></tr></thead><tbody>");

            foreach (var fixture in group.OrderBy(x => x.Fixture.Date).ThenBy(x => x.Teams.Home.Name))
            {
                var pred = _predictions[fixture.Fixture.Id];
                var homeScore = pred.Home;
                var awayScore = pred.Away;
                if (homeScore == null || awayScore == null)
                    missing = true;

                var homeTeam = fixture.Teams.Home.Name.Trim();
                var awayTeam = fixture.Teams.Away.Name.Trim();
                sbText.AppendLine($"{homeTeam}    {homeScore} - {awayScore}    {awayTeam}");
                sbHtml.Append($"<tr><td style=\"padding: 5px; text-align: left;\">{homeTeam}</td><td style=\"padding: 5px; text-align: center;\">{homeScore} - {awayScore}</td><td style=\"padding: 5px; text-align: right;\">{awayTeam}</td></tr>");
            }

            sbText.AppendLine();
        }

        sbHtml.Append("</tbody></table><br/>");

        if (missing)
        {
            await Browser.AlertAsync("Error: Please fill in all score predictions before copying.");
            return;
        }

        var mobile = await Browser.IsMobileDeviceAsync();
        if (mobile)
            await Browser.CopyToClipboardTextAsync(sbText.ToString());
        else
            await Browser.CopyToClipboardHtmlAsync(sbHtml.ToString());
    }

    private void ResetRange()
    {
        NavigationManager.NavigateTo("/");
    }

    private class PredictionInput
    {
        public int? Home { get; set; }
        public int? Away { get; set; }
    }
}
